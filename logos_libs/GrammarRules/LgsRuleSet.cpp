/*
This file is part of OpenLogos/LogOSMaTrans.  Copyright (C) 2005 Globalware AG

OpenLogos/LogOSMaTrans has two licensing options:

The Commercial License, which allows you to provide commercial software
licenses to your customers or distribute Logos MT based applications or to use
LogOSMaTran for commercial purposes. This is for organizations who do not want
to comply with the GNU General Public License (GPL) in releasing the source
code for their applications as open source / free software.

The Open Source License allows you to offer your software under an open source
/ free software license to all who wish to use, modify, and distribute it
freely. The Open Source License allows you to use the software at no charge
under the condition that if you use OpenLogos/LogOSMaTran in an application you
redistribute, the complete source code for your application must be available
and freely redistributable under reasonable conditions. GlobalWare AG bases its
interpretation of the GPL on the Free Software Foundation's Frequently Asked
Questions.

OpenLogos is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the License conditions along with this
program. If not, write to Globalware AG, Hospitalstraﬂe 6, D-99817 Eisenach.

Linux port modifications and additions by Bernd Kiefer, Walter Kasper,
Deutsches Forschungszentrum fuer kuenstliche Intelligenz (DFKI)
Stuhlsatzenhausweg 3, D-66123 Saarbruecken
*/
// LgsRuleSet.cpp: implementation of the CLgsRuleSet class.
//
//////////////////////////////////////////////////////////////////////

#ifdef _MSC_VER
#include <logos_libs/GrammarRules/stdafx.h>
#endif
#include <logos_libs/GrammarRules/LgsPass.h>
#include <logos_libs/GrammarRules/LgsLanguage.h>
#include <logos_libs/GrammarRules/LgsTypeStatement.h>
#include <logos_libs/GrammarRules/LgsSpElement.h>
#include <logos_libs/GrammarRules/LgsVtrStatement.h>
#include <logos_libs/GrammarRules/LgsSortKeyTemplate.h>
#include <logos_libs/GrammarRules/ExtRec.h>
#include <logos_libs/GrammarRules/LgsRule.h>
#include <logos_libs/GrammarRules/LgsRuleSet.h>

#include <fstream>

IMPLEMENT_SERIAL(CLgsRuleSet,CObject,1);

const unsigned long CLgsRuleSet::m_magicVal = 0xeeee4137;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CLgsRuleSet::CLgsRuleSet()
{
    m_mainMiniCode = "";
    m_langSource = NULL;
    m_langTarget = NULL;
    m_pass = NULL;
    m_description = "";
	m_sorted = false;
	m_sortOrder = "None";
	m_skTmp = NULL;
}

CLgsRuleSet::CLgsRuleSet(LPCTSTR pass, LPCTSTR srcL, LPCTSTR tgtL)
{
    m_langSource = new CLgsLanguage();
	m_langSource->parse(srcL);

    m_langTarget = new CLgsLanguage();
	m_langTarget->parse(tgtL);

    m_pass = new CLgsPass();
	m_pass->parse(pass);

    m_mainMiniCode = "";
    m_description = "";
	m_sorted = false;
	m_sortOrder = "None";
	m_skTmp = NULL;
}

CLgsRuleSet::CLgsRuleSet(LPCTSTR file)
{
	// if an exception generated by this code,
	// it should be handled by the caller
	CFile in(file, CFile::modeRead|CFile::shareDenyWrite);
	CArchive arIn(&in, CArchive::load);
	Serialize(arIn);
	arIn.Close();
	in.Close();
}

CLgsRuleSet::~CLgsRuleSet()
{
	if (m_langSource)
      delete m_langSource;
	if (m_langTarget)
      delete m_langTarget;
	if (m_pass)
      delete m_pass;

	for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
		delete (*i);

	if (m_skTmp)
		delete m_skTmp;
}

void CLgsRuleSet::Serialize(CArchive& ar)
{
	bool isThere;
	int xxx;
	unsigned long _mm;
	unsigned int _ll;

	if (ar.IsStoring())
	{
		ar << m_magicVal;

		isThere = NULL != m_langSource;
		ar << isThere;
		if (isThere) m_langSource->Serialize(ar);

		isThere = NULL != m_langTarget;
		ar << isThere;
		if (isThere) m_langTarget->Serialize(ar);

		isThere = NULL != m_pass;
		ar << isThere;
		if (isThere) m_pass->Serialize(ar);

		ar << m_description.length();
		if (m_description.length() > 0)
			ar.Write(m_description.c_str(), m_description.length());

		ar << m_mainMiniCode.length();
		if (m_mainMiniCode.length() > 0)
			ar.Write(m_mainMiniCode.c_str(), m_mainMiniCode.length());

		ar << m_rule.size();
		for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
			(*i)->Serialize(ar);

		ar << (int)m_sorted;

		ar << m_sortOrder.length();
		if (m_sortOrder.length() > 0)
			ar.Write(m_sortOrder.c_str(), m_sortOrder.length());

		isThere = NULL != m_skTmp;
		ar << isThere;
		if (isThere) m_skTmp->Serialize(ar);
	}
	else
	{
		ar >> _mm;
		if (_mm != m_magicVal)
			return;

		ar >> xxx; isThere = 0 != xxx;
		if (isThere)
		{
			if (!m_langSource) m_langSource = new CLgsLanguage();
			m_langSource->Serialize(ar);
		}
		else
		{
			if (m_langSource)
			{
				delete m_langSource;
				m_langSource = NULL;
			}
		}

		ar >> xxx; isThere = 0 != xxx;
		if (isThere)
		{
			if (!m_langTarget) m_langTarget = new CLgsLanguage();
			m_langTarget->Serialize(ar);
		}
		else
		{
			if (m_langTarget)
			{
				delete m_langTarget;
				m_langTarget = NULL;
			}
		}

		ar >> xxx; isThere = 0 != xxx;
		if (isThere)
		{
			if (!m_pass) m_pass = new CLgsPass();
			m_pass->Serialize(ar);
		}
		else
		{
			if (m_pass)
			{
				delete m_pass;
				m_pass = NULL;
			}
		}

		m_description.erase();
		ar >> _ll;
		if (_ll > 0)
		{
			char* b = new char[_ll+1];
			if (_ll != ar.Read(b, _ll))
				throw("");
			b[_ll] = 0;
			m_description = b;
			delete[] b;
		}

		m_mainMiniCode.erase();
		ar >> _ll;
		if (_ll > 0)
		{
			char* b = new char[_ll+1];
			if (_ll != ar.Read(b, _ll))
				throw("");
			b[_ll] = 0;
			m_mainMiniCode = b;
			delete[] b;
		}

		for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin();
				i != m_rule.end(); i++)
			delete (*i);
		m_rule.erase(m_rule.begin(), m_rule.end());
		int numRules;
		ar >> numRules;
		for (int j = 0; j < numRules; j++)
		{
			CLgsRule* rule = new CLgsRule();
			rule->Serialize(ar);
			m_rule.push_back(rule);
		}
		ar >> xxx; m_sorted = xxx != 0;

		m_sortOrder.erase();
		ar >> _ll;
		if (_ll > 0)
		{
			char* b = new char[_ll+1];
			if (_ll != ar.Read(b, _ll))
				throw("");
			b[_ll] = 0;
			m_sortOrder = b;
			delete[] b;
		}

		ar >> xxx; isThere = 0 != xxx;
		if (isThere)
		{
			if (!m_skTmp) m_skTmp = new CLgsSortKeyTemplate();
			m_skTmp->Serialize(ar);
			// if ruleset has a sort key template associated with it,
			// m_sortOrder must have correct value
			if (0 == m_sortOrder.length())
				throw("");
		}
		else
		{
			// no skTmpl
			if (m_skTmp)
			{
				delete m_skTmp;
				m_skTmp = NULL;
				m_sortOrder.erase();
			}
		}
	}
}

LPCTSTR CLgsRuleSet::Source()
{
	LPCTSTR result = NULL;
	if (m_langSource) result = m_langSource->toString();
	return result;
}

bool CLgsRuleSet::Source(LPCTSTR lang)
{
	bool result = false;
	CLgsLanguage* newLang = new CLgsLanguage();
	if (newLang->parse(lang))
	{
		if (m_langSource)
         delete m_langSource;
		m_langSource = newLang;
		result = true;
	}
	else
		delete newLang;

	return result;
}

LPCTSTR CLgsRuleSet::Target()
{
	LPCTSTR result = NULL;
	if (m_langTarget) result = m_langTarget->toString();
	return result;
}

bool CLgsRuleSet::Target(LPCTSTR lang)
{
	bool result = false;
	CLgsLanguage* newLang = new CLgsLanguage();
	if (newLang->parse(lang))
	{
		if (m_langTarget)
         delete m_langTarget;
		m_langTarget = newLang;
		result = true;
	}
	else
		delete newLang;

	return result;
}

LPCTSTR CLgsRuleSet::Pass()
{
	LPCTSTR result = NULL;
	if (m_pass) result = m_pass->toString();
	return result;
}

bool CLgsRuleSet::Pass(LPCTSTR pass)
{
	bool result = false;
	CLgsPass* newPass = new CLgsPass();
	if (newPass->parse(pass))
	{
		if (m_pass)
         delete m_pass;
		m_pass = newPass;
		result = true;
	}
	else
		delete newPass;

	return result;
}

LPCTSTR CLgsRuleSet::Description()
{
	return m_description.c_str();
}

void CLgsRuleSet::Description(LPCTSTR description)
{
	m_description = description;
}

void CLgsRuleSet::Add(CLgsRule* rule, int insertAfter)
{
	rule->id(GetNextId());

	if (-1 == insertAfter || insertAfter < m_rule.size() -1)
		m_rule.push_back(rule);
	else
		m_rule.insert(m_rule.begin() + insertAfter + 1, rule);
}

CLgsRule* CLgsRuleSet::Replace(CLgsRule* rule, int insertAfter)
{
	// return:
	//		-1		- nothing has been done
	//		NULL	- rule has been added to ruleset
	//		other	- arg replaces a rule in the ruleset, the return value
	//				  is the old rule pointer
	CLgsRule* result = (CLgsRule*)-1;

	if (-1 == rule->id())
	{
		Add(rule, insertAfter);
		result = NULL;
	}
	else
	{
		for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
		{
			if (rule->id() == (*i)->id())
			{
				result = *i;
				*i = rule;
				break;
			}
		}
	}

	return result;
}

bool CLgsRuleSet::Delete(CLgsRule* rule)
{
	bool result = false;
	for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
	{
		if (rule == *i)
		{
			//delete (*i);
			m_rule.erase(i);
			result = true;
			break;
		}
	}

	return result;
}

int CLgsRuleSet::NumberOfRules()
{
	return m_rule.size();
}

CLgsRule* CLgsRuleSet::GetItem(int i)
{
	CLgsRule* result = NULL;
	if (i >= 0 && i < m_rule.size()) result = m_rule[i];
	return result;
}

void CLgsRuleSet::DeleteAll()
{
	for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
		delete (*i);
	m_rule.erase(m_rule.begin(), m_rule.end());
}

// compare function which is called by qsort
static int __cdecl CompareCb(const void* e1, const void* e2)
{
	CLgsRuleSet::CCmpElem* ce1 = (CLgsRuleSet::CCmpElem*)e1;
	CLgsRuleSet::CCmpElem* ce2 = (CLgsRuleSet::CCmpElem*)e2;
	bool asc = ce1->m_ascending;
	CLgsRule* r1 = asc ? ce1->m_rule : ce2->m_rule;
	CLgsRule* r2 = asc ? ce2->m_rule : ce1->m_rule;
	return r1->Compare(r2, ce1->m_skTmp);
}

void CLgsRuleSet::Sort(CLgsSortKeyTemplate * skTmp, bool ascending)
{
	if (!skTmp || 0 == m_rule.size())
		return;

	CCmpElem (*buf) = new CCmpElem[m_rule.size()];

        int i;
	for (i = 0; i < m_rule.size(); i++)
	{
		buf[i].m_ascending = ascending;
		buf[i].m_rule = m_rule[i];
		buf[i].m_skTmp = skTmp;
	}

	qsort((void*)buf, m_rule.size(), sizeof(CCmpElem), CompareCb);

	// put the new order back to m_rule array
	for (i = 0; i < m_rule.size(); i++)
		m_rule[i] = buf[i].m_rule;

	delete[] buf;

	m_sorted = true;
	m_sortOrder = ascending ? "Ascending" : "Descending";
	// make private copy of sort key template
	if (m_skTmp)
		delete m_skTmp;
	m_skTmp = new CLgsSortKeyTemplate();
	m_skTmp->CopyFrom(skTmp);
}

bool CLgsRuleSet::IsSorted()
{
	return m_sorted;
}

CLgsSortKeyTemplate* CLgsRuleSet::GetSortKeyTemplate()
{

	CLgsSortKeyTemplate* result = NULL;
	if (m_sorted)
	{
		// since we have our private copy of the template,
		// return a copy to the caller
		result = new CLgsSortKeyTemplate();
		result->CopyFrom(m_skTmp);
	}
	return result;
}

LPCTSTR CLgsRuleSet::GetSortOrder()
{
	return m_sortOrder.c_str();
}

bool CLgsRuleSet::QueryBounds(
		int* wcMin, int* wcMax,
		int* tyMin, int* tyMax)
{
	bool result = false;
	if (!wcMin || !wcMax || !tyMin || !tyMax)
		return false;

	int numRules = m_rule.size();
	if (numRules > 0)
	{
		int wc_min = 1000000;
		int wc_max = -1000000;
		int ty_min = 1000000;
		int ty_max = -1000000;

		for (int i = 0; i < numRules; i++)
		{
			CLgsSpElement** sps = NULL;
			m_rule[i]->SpStatements(&sps);
			int wc = sps[0]->WordClass();
			short* nums;
			int numNums = sps[0]->TypeStatement()->GetNumbers(&nums);
			int ty = !(numNums == 1 && !sps[0]->TypeStatement()->GetHints())
						? -2 : nums[0];

			if (wc_min > wc) wc_min = wc;
			if (wc_max < wc) wc_max = wc;
			if (ty_min > ty) ty_min = ty;
			if (ty_max < ty) ty_max = ty;
		}

		*wcMin = wc_min;
		*wcMax = wc_max;
		*tyMin = ty_min;
		*tyMax = ty_max;
		result = true;
	}
// This is for RES minis to match, will not make
// any difference for all other big rulesets.
// See init_wcix in res_rule_io.cpp and res2x.c
*wcMin = 1;
*wcMax = 20;

	return result;
}

bool CLgsRuleSet::BuildIndex(
		int** startIndex, int** countIndex,
		int** startNegIndex, int** countNegIndex, bool wcOnly)
{
	// verify that the rules have been sorted using
	// proper sort order and sort key template,
	// otherwise index can't be built
	//
	// the requirments are:
	//	1. rules should be sorted in ascending order
	//	2. WC and TY (WC if wcOnly is true) of the first SP element
	//		should be most significant match items
	//		in the sort key template
	if (!IsSorted() ||
		 !m_skTmp->IsOKForBuildingWCTYIndex(wcOnly) ||
		 m_sortOrder.compare("Ascending"))
		return false;

	if ((startIndex && !countIndex) || (!startIndex && countIndex) ||
		 (startNegIndex && !countNegIndex) || (!startNegIndex && countNegIndex) ||
		 (!startIndex && ! startNegIndex))
		return false;

	int wcMin, wcMax, tyMin, tyMax;
	if (!QueryBounds(&wcMin, &wcMax, &tyMin, &tyMax))
		return false; // empty rule set

	int wcNum = wcMax - wcMin +1;
	int tyNum = tyMax - tyMin +1;
	if (wcNum <= 0 || tyNum <= 0)
		return false;

	int* startIx = NULL;
	int* countIx = NULL;
	if (startIndex)
	{
		// if wcOnly is true the memory allocated here is more than actually needed
		startIx = new int[wcNum * tyNum];
		countIx = new int[wcNum * tyNum];
		for (int i = 0; i < wcNum * tyNum; i++)
		{
			startIx[i] = -1;
			countIx[i] = 0;
		}
	}

	int* startNegIx = NULL;
	int* countNegIx = NULL;
	if (startNegIndex)
	{
		startNegIx = new int[wcNum];
		countNegIx = new int[wcNum];
		for (int i = 0; i < wcNum; i++)
		{
			startNegIx[i] = -1;
			countNegIx[i] = 0;
		}
	}

//printf("BuildIndexes: wcMin(ax)=(%d,%d), wcNum=%d, size=%d\n", 
//	   wcMin, wcMax, wcNum, m_rule.size());
//fflush(stdout);
	int wc, ty;
	int wcPrev, tyPrev;
	for (int i = 0; i < m_rule.size(); wcPrev = wc, tyPrev = ty, i++)
	{
		CLgsSpElement** sps = NULL;
		m_rule[i]->SpStatements(&sps);
		wc = sps[0]->WordClass();
		short* nums;
		int numNums = sps[0]->TypeStatement()->GetNumbers(&nums);
		ty = !(1 == numNums && !sps[0]->TypeStatement()->GetHints())
				? -2 : nums[0];

		if (startIndex)
		{
			if (wcOnly)
			{
				// start position & count of subset of rules with given wc value
				if (0 == i)
					startIx[wc - wcMin] = i;
				else if (wc != wcPrev)
						startIx[wc - wcMin] = i;
				countIx[wc - wcMin]++;
			}
			else
			{
				// start position & count of subset of rules with given (wc,ty)
				if (0 == i)
					startIx[tyNum*(wc - wcMin) + (ty-tyMin)] = i;
				else if (wc != wcPrev || ty != tyPrev)
						startIx[tyNum*(wc - wcMin) + (ty-tyMin)] = i;
				countIx[tyNum*(wc - wcMin) + (ty-tyMin)]++;
			}
		}

		// start & count of subset of rules with negative ty for any given wc
		// Building these two indexes assumes that the array of rules
		// is sorted in ascending order.
		if (startNegIndex)
		{
			if (0 == i)
				startNegIx[wc - wcMin] = i;
			else if (wc != wcPrev)
					startNegIx[wc - wcMin] = i;
			if (ty < 0)
				countNegIx[wc - wcMin]++;
		}
	}

	if (startIndex)
	{
		*startIndex = startIx;
		*countIndex = countIx;
	}
	if (startNegIndex)
	{
		*startNegIndex = startNegIx;
		*countNegIndex = countNegIx;
	}
	return true;
}

LPCTSTR CLgsRuleSet::MainMiniCode() { return m_mainMiniCode.c_str(); }
void CLgsRuleSet::MainMiniCode(LPCTSTR code) { m_mainMiniCode = code; }

int CLgsRuleSet::GetNextId()
{
	int result = -1;

	for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
	{
		if (result < (*i)->id())
			result = (*i)->id();
	}

	result += 1;
	return result;
}

CLgsRule* CLgsRuleSet::IsIn(CLgsRule* src)
{
	VERIFY(src);

	for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
	{
		if (src->IsEqualTo(*i))
			return *i;
	}
	return NULL;
}

int CLgsRuleSet::GetItemIndex(CLgsRule* src)
{
	VERIFY(src);

	for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
	{
		if (src == *i)
			return i - m_rule.begin();
	}

	return -1;
}

void CLgsRuleSet::AddRule(CLgsRule *rule, int insertAfter)
{
	if (-1 == insertAfter || insertAfter < m_rule.size() -1)
		m_rule.push_back(rule);
	else
		m_rule.insert(m_rule.begin() + insertAfter + 1, rule);
}

void CLgsRuleSet::SaveAsText(LPCTSTR fileName)
{
   ofstream out(fileName, ios_base::out);
   char tmp[16];
   for (LgsVector(CLgsRule*)::iterator i =  m_rule.begin(); i != m_rule.end(); i++)
   {
      //out << (*i)->toString();
      sprintf(tmp, "%02d", (*i)->Level());
      char *c1 = (*i)->CommentDisplayString(false);
      char *s1 = (*i)->SpsDisplayString(false);
      char *t1 = (*i)->TagsetsDisplayString(false, false);
      char *v1 = (*i)->VtrsDisplayString(false, false);
      LgsString str = tmp;
      str+= ' ';
      str+= c1;
      str+= '\n';
      str+= s1;
      str+= '\n';
      if ( t1[0] )
      {
         str+= t1;
         str+= '\n';
      }
      str+= v1;
      str+= '\n';
      delete c1; delete s1; delete t1; delete v1;
      out << str << "$\n" << flush;
   }
   out.close();
}
