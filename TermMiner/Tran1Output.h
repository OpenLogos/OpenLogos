/*
This file is part of OpenLogos/LogOSMaTrans.  Copyright (C) 2005 Globalware AG

OpenLogos/LogOSMaTrans has two licensing options:

The Commercial License, which allows you to provide commercial software
licenses to your customers or distribute Logos MT based applications or to use
LogOSMaTran for commercial purposes. This is for organizations who do not want
to comply with the GNU General Public License (GPL) in releasing the source
code for their applications as open source / free software.

The Open Source License allows you to offer your software under an open source
/ free software license to all who wish to use, modify, and distribute it
freely. The Open Source License allows you to use the software at no charge
under the condition that if you use OpenLogos/LogOSMaTran in an application you
redistribute, the complete source code for your application must be available
and freely redistributable under reasonable conditions. GlobalWare AG bases its
interpretation of the GPL on the Free Software Foundation's Frequently Asked
Questions.

OpenLogos is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the License conditions along with this
program. If not, write to Globalware AG, Hospitalstraße 6, D-99817 Eisenach.

Linux port modifications and additions by Bernd Kiefer, Walter Kasper,
Deutsches Forschungszentrum fuer kuenstliche Intelligenz (DFKI)
Stuhlsatzenhausweg 3, D-66123 Saarbruecken
*/
// Tran1Output.h: interface for the Tran1Output class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _Tran1Output_h_
#define _Tran1Output_h_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// --------------------------------------------------------------------------
// Definition of a phrase generated by Tran1. This is a SWORK at the end of the Tran1
// process. It is used in Tran1_io to capture Tran1 result information for term search
// purposes.
// --------------------------------------------------------------------------
class Tran1Output: public Object 
{
public:
	// default constructor (needed for STL)
	Tran1Output();

	// constructor for Tran1_io.cpp to capture result from Tran1 process
	Tran1Output(LgsString,int,int,int,int,int);

	virtual ~Tran1Output();

	// display content of this object (for debug)
	void display();

	// append a scon pointer in the sequence of elements forming this output
	// a scon pointer corresponds to a source sentence unit (SSU) sequence number
	void appendSconPointerElement(int);

	void appendOpadrElement(int);

	// put information of this object as a sequence of characters (for message passing strategy)
	int streamOutSize();				// number of bytes required to store object content in memory
	void streamOut(char*&);			// the object content as a sequence of characters

	// getter methods
	LgsString headWordSurfaceForm();
	int headWordPOS();
	int headWordSSSet();
	int headWordForm();
	int headWordSourceUnitNumber();
	int scon1();
	int numberElements();

protected:
	// obtained from sent_wordsX_.source_word[] C structure (see tran1_io.cpp)
	LgsString headWordSurfaceForm_;

	// word class - obtained from sworkoX_.sworko[] (see tran1_io.cpp)
	int headWordPOS_;

	// superset or set or subset - obtained from sworkoX_.sworko[] (see tran1_io.cpp)
	int headWordSSSet_;

	// form code - obtained from sworkoX_.sworko[] (see tran1_io.cpp)
	int headWordForm_;

	// corresponding SSU number - obtained from sworkoX_.sworko[] (see tran1_io.cpp)
	int headWordSourceUnitNumber_;

	// value of scon1 - used to determine German source NPs - obtained from sconX_.scon structure
	int scon1_;

	// SCONPO in target sequence order (from the end of Tran1)
	// sequence of SSU numbers (scon pointers) forming the output under this head (incl. head)
	// the sequence is in target sequence order.
	// Obtained from structure opadroX_.sconpo[] (see tran1_io.cpp)
	LgsList(int) elementsInTargetSequenceOrder_;		// original sequence order form Tran1 output

	// OPADRO in target sequence order (from the end of Tran1)
	// Obtained from structure opadroX_.opadro[] (see tran1_io.cpp)
	// for each i: OPADRO[i] corresponds to SCONPO[i]
	LgsList(int) opadro_;
};

// --------------------------------------------------------------------------
// Interface for a sequence of Tran1Output objects
// --------------------------------------------------------------------------
class Tran1OutputSequence : public LgsVector(Tran1Output)
{
public:
	Tran1OutputSequence();
	virtual ~Tran1OutputSequence();

	void append(Tran1Output);
	void appendNextSourceWord(LgsString);

	// display content of this object (for debug)
	void display();

	// put information of this object as a sequence of characters (for message passing strategy)
	int streamOutSize();				// number of bytes required to store object content in memory
	void streamOut(char*&);			// the object content as a sequence of characters

	// account in the sequence of source words for any switch68 that have been added
	void accountForSwitch68(LgsString);

private:
	// original source sentence elements (words) as in Tran1 (relate to the scon pointers)
	LgsStringVector sourceWords_;
};

typedef Tran1OutputSequence::iterator Tran1OutputIterator;

// --------------------------------------------------------------------------
// Append a scon pointer in the sequence of elements forming this output.
// A scon pointer corresponds to a source sentence unit (SSU) sequence number.
// --------------------------------------------------------------------------
inline void Tran1Output::appendSconPointerElement(int aSconPointer)
{
	elementsInTargetSequenceOrder_.push_back(aSconPointer);
}

// --------------------------------------------------------------------------
inline void Tran1Output::appendOpadrElement(int element)
{
	opadro_.push_back(element);
}

// --------------------------------------------------------------------------
inline LgsString Tran1Output::headWordSurfaceForm()
{
	return headWordSurfaceForm_;
}

// --------------------------------------------------------------------------
inline int Tran1Output::headWordPOS()
{
	return headWordPOS_;
}

// --------------------------------------------------------------------------
inline int Tran1Output::headWordSSSet()
{
	return headWordSSSet_;
}

// --------------------------------------------------------------------------
inline int Tran1Output::headWordForm()
{
	return headWordForm_;
}

// --------------------------------------------------------------------------
inline int Tran1Output::headWordSourceUnitNumber()
{
	return headWordSourceUnitNumber_;
}

// --------------------------------------------------------------------------
inline int Tran1Output::scon1()
{
	return scon1_;
}

// --------------------------------------------------------------------------
inline void Tran1OutputSequence::appendNextSourceWord(LgsString aWord)
{
	sourceWords_.push_back(aWord);
}

// --------------------------------------------------------------------------
inline void Tran1OutputSequence::append(Tran1Output anOutput)
{
	push_back(anOutput);
}

#endif // _Tran1Output_h_
