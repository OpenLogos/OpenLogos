/*
This file is part of OpenLogos/LogOSMaTrans.  Copyright (C) 2005 Globalware AG

OpenLogos/LogOSMaTrans has two licensing options:

The Commercial License, which allows you to provide commercial software
licenses to your customers or distribute Logos MT based applications or to use
LogOSMaTran for commercial purposes. This is for organizations who do not want
to comply with the GNU General Public License (GPL) in releasing the source
code for their applications as open source / free software.

The Open Source License allows you to offer your software under an open source
/ free software license to all who wish to use, modify, and distribute it
freely. The Open Source License allows you to use the software at no charge
under the condition that if you use OpenLogos/LogOSMaTran in an application you
redistribute, the complete source code for your application must be available
and freely redistributable under reasonable conditions. GlobalWare AG bases its
interpretation of the GPL on the Free Software Foundation's Frequently Asked
Questions.

OpenLogos is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the License conditions along with this
program. If not, write to Globalware AG, Hospitalstraße 6, D-99817 Eisenach.

Linux port modifications and additions by Bernd Kiefer, Walter Kasper,
Deutsches Forschungszentrum fuer kuenstliche Intelligenz (DFKI)
Stuhlsatzenhausweg 3, D-66123 Saarbruecken
*/
// TermSearchSentenceUnit.h: interface for the TermSearchSentenceUnit class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _TermSearchSentenceUnit_h_
#define _TermSearchSentenceUnit_h_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <TermMiner/Tran1Unit.h>
#include <TermMiner/TermElement.h>

class LSentence;

// --------------------------------------------------------------------------
// This object combines all information gathered from Lookup, Tran1, and generate
// in order to define a Term. Basically, it defines the main word and its possibly
// element. Each is a TermElement that combines related SSU and TSU.
// --------------------------------------------------------------------------
class TermSearchSentenceUnit : public Object
{
public:
	TermSearchSentenceUnit(Tran1Unit,LSentence*,int);
	virtual ~TermSearchSentenceUnit();
	int numberSourceElements();
	LgsString sourceSurfaceForm();
	LgsString targetSurfaceForm();
	bool isTran1NounPhrase();			// whether this unit is a noun phrase generated by Tran1
	bool isTran1GermanCompound();		// whether this unit is a German compound that has been decomposed
	bool isTran1InsertedElement();	// whether this unit is an element inserted by Tran1 (switch68)
	bool isUnfoundNoun();
	bool isProtected();
	LgsString context();
	LSentence* sentence();
	int sourceLocationInSentence();
	int transferStatus();
	void report(ostream&);				// report in the specified output stream
	TermElement& headElement();
	TermElementVector& elementsInSourceSequenceOrder();
	TermElementVector& elementsInTargetSequenceOrder();
	LgsList(int)& sourceScons();
	LgsList(int)& targetScons();
	bool isSetCorrectly();
	void reset();
	LgsString sourceSconsAsString();
	LgsString targetSconsAsString();

private:
	Tran1Unit tran1Unit_;				// info from Tran1 analysis
	LSentence* sentence_;				// info from the sentence (Lookup, RES, and Generate info)
	
	// information about the head element of the term
	TermElement headElement_;
	void definesHeadElement();		// set headElement_ and setCorrectly_
	
	// information about all the elements grouped under the head for the source
	int numberSW68_;		// number of SWITCH68 in the sentence
	LgsList(int) sourceScons_;
	LgsList(int) targetScons_;
	TermElementVector elementsSourceSeqOrder_;		// the elements concatenated under the head element (including head) in source sequence order
	void definesAllElementsInSourceSequenceOrder();		// all elements in source sequence order
	void reportSourceElements(ostream&);
	void reportSourceScons(ostream&);
	LgsString sourceSurfaceForm_;							// surface form of the unit (head and its elements)
	void computeSourceSurfaceForm();
	
	// information about all the elements grouped under the head for the target
	void definesAllElements();
	TermElementVector elementsTargetSeqOrder_;		// the elements concatenated under the head element (including head) in target sequence order
	void definesAllElementsInTargetSequenceOrder();		// all elements in target sequence order
	void reportTargetElements(ostream&);
	void reportTargetScons(ostream&);
	LgsString targetSurfaceForm_;							// surface form of the unit (head and its elements)
	void computeTargetSurfaceForm();
	
	bool setCorrectly_;
};

// --------------------------------------------------------------------------
// Definition of a vector of TermSearchSentenceUnit objects
// --------------------------------------------------------------------------
typedef LgsVector(TermSearchSentenceUnit) TermSearchSentenceUnitVector;
typedef TermSearchSentenceUnitVector::iterator TermSearchSentenceUnitIterator;

// --------------------------------------------------------------------------
inline LgsString TermSearchSentenceUnit::sourceSurfaceForm()
{
	return sourceSurfaceForm_;
}

// --------------------------------------------------------------------------
inline LgsString TermSearchSentenceUnit::targetSurfaceForm()
{
	return targetSurfaceForm_;
}

// --------------------------------------------------------------------------
inline TermElement& TermSearchSentenceUnit::headElement()
{
	return headElement_;
}

// --------------------------------------------------------------------------
inline TermElementVector& TermSearchSentenceUnit::elementsInSourceSequenceOrder()
{
	return elementsSourceSeqOrder_;
}

// --------------------------------------------------------------------------
inline TermElementVector& TermSearchSentenceUnit::elementsInTargetSequenceOrder()
{
	return elementsTargetSeqOrder_;
}

// --------------------------------------------------------------------------
inline LgsList(int)& TermSearchSentenceUnit::sourceScons()
{
	return sourceScons_;
}

// --------------------------------------------------------------------------
inline LgsList(int)& TermSearchSentenceUnit::targetScons()
{
	return targetScons_;
}

// --------------------------------------------------------------------------
inline LSentence* TermSearchSentenceUnit::sentence()
{
	return sentence_;
}

// --------------------------------------------------------------------------
inline int TermSearchSentenceUnit::numberSourceElements()
{
	return sourceScons_.size();
}

// --------------------------------------------------------------------------
inline bool TermSearchSentenceUnit::isSetCorrectly()
{
	return setCorrectly_;
}

#endif // _TermSearchSentenceUnit_h_
