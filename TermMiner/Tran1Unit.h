/*
This file is part of OpenLogos/LogOSMaTrans.  Copyright (C) 2005 Globalware AG

OpenLogos/LogOSMaTrans has two licensing options:

The Commercial License, which allows you to provide commercial software
licenses to your customers or distribute Logos MT based applications or to use
LogOSMaTran for commercial purposes. This is for organizations who do not want
to comply with the GNU General Public License (GPL) in releasing the source
code for their applications as open source / free software.

The Open Source License allows you to offer your software under an open source
/ free software license to all who wish to use, modify, and distribute it
freely. The Open Source License allows you to use the software at no charge
under the condition that if you use OpenLogos/LogOSMaTran in an application you
redistribute, the complete source code for your application must be available
and freely redistributable under reasonable conditions. GlobalWare AG bases its
interpretation of the GPL on the Free Software Foundation's Frequently Asked
Questions.

OpenLogos is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the License conditions along with this
program. If not, write to Globalware AG, Hospitalstraße 6, D-99817 Eisenach.

Linux port modifications and additions by Bernd Kiefer, Walter Kasper,
Deutsches Forschungszentrum fuer kuenstliche Intelligenz (DFKI)
Stuhlsatzenhausweg 3, D-66123 Saarbruecken
*/
// Tran1Unit.h: interface for the Tran1Unit class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _Tran1Unit_h_
#define _Tran1Unit_h_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <TermMiner/Tran1Output.h>

#define TARGET_ARRAYS_MAX_SIZE 100

// --------------------------------------------------------------------------
// Definition of an unit generated by Tran1. This is a SWORK at the 
// end of the Tran1 process. It is used in Tran1_io to capture Tran1 result 
// information for term search purposes.
// --------------------------------------------------------------------------
class Tran1Unit: public Tran1Output 
{
public:
	Tran1Unit();						// default constructor
	Tran1Unit(char*&);				// set unit from message sent by Tran1
	virtual ~Tran1Unit();			// destructor
	void display();					// display content of this object (for debug)
	void report(ostream&);			// display formatted content in specified output stream

	// get information about the head word
	int headWordPOS();
	int headWordSSSet();
	int headWordForm();
	int headWordSourceUnitNumber();
	bool isUnfound();		// status based only on Tran1 output
	int scon1();
	LgsList(int)* elementsInSourceSequenceOrder();
	LgsList(int) elementsInTargetSequenceOrder();
	bool isValidForTermSearch();

	// access info about the target arrays
	void resetArrayIndex();
	void nextArrayIndex();
	bool isValidArrayIndex();
	int currentSconpo();
	int currentOpadro();
	int currentTargetArrayValueFor(int);
	int numberInstancesOfSconValue(int);

private:
	LgsList(int) elementsInSourceSequenceOrder_;			// scon pointers in source elements order

	// maintain OPADRO and SCONPO arrays from end of Tran1 as a single table (each i-th element has
	// its corresponding element in the other arrays)
	enum arrays
	{
		OPADRO = 0,
		SCONPO = 1
	};
	int tran1TargetArrays_[TARGET_ARRAYS_MAX_SIZE][2];
	int tran1TargetArraysSize_;
	void constructTargetArraysTable(int,int);
	int arrayIndex_;
};


// --------------------------------------------------------------------------
// Interface for a sequence of Tran1Unit objects
// --------------------------------------------------------------------------
class Tran1UnitSequence : public LgsVector(Tran1Unit)
{
public:
	Tran1UnitSequence();							// set the sequence of objects by reading message sent by Tran1
	virtual ~Tran1UnitSequence();				// destructor
	void append(Tran1Unit);
	void appendNextSourceWord(LgsString);
	void display();								// display content of this object (for debug)
	void report(ostream&);
	LgsStringVector* sourceWords();
	int numberOfSwitch68();

private:
	// original source sentence elements (words) as in Tran1 (relate to the scon pointers)
	LgsStringVector sourceWords_;

	void readInTran1Message();					// set feature from message sent by Tran1 (source analysis)

	int numberSW68_;
	void countNumberOfSwitch68();
};

typedef Tran1UnitSequence::iterator Tran1UnitIterator;

// --------------------------------------------------------------------------
inline int Tran1Unit::headWordPOS()
{
	return headWordPOS_;
}

// --------------------------------------------------------------------------
inline int Tran1Unit::headWordSSSet()
{
	return headWordSSSet_;
}

// --------------------------------------------------------------------------
inline int Tran1Unit::headWordForm()
{
	return headWordForm_;
}

// --------------------------------------------------------------------------
inline int Tran1Unit::headWordSourceUnitNumber()
{
	return headWordSourceUnitNumber_;
}

// --------------------------------------------------------------------------
inline bool Tran1Unit::isUnfound()
{
	return headWordForm_ == 33;		// status based only on Tran1 output
}

// --------------------------------------------------------------------------
inline int Tran1Unit::scon1()
{
	return scon1_;
}

// --------------------------------------------------------------------------
inline LgsList(int)* Tran1Unit::elementsInSourceSequenceOrder()
{
	return &elementsInSourceSequenceOrder_;
}

// --------------------------------------------------------------------------
inline LgsList(int) Tran1Unit::elementsInTargetSequenceOrder()
{
	return elementsInTargetSequenceOrder_;
}

// --------------------------------------------------------------------------
// Display formatted content in specified output stream
// --------------------------------------------------------------------------
inline void Tran1Unit::display()
{
	report(cout);
}

// --------------------------------------------------------------------------
// Display content of the sequence of objects (debug)
// --------------------------------------------------------------------------
inline void Tran1UnitSequence::display()
{
	report(cout);
}

// --------------------------------------------------------------------------
inline void Tran1UnitSequence::append(Tran1Unit aUnit)
{
	push_back(aUnit);
}

// --------------------------------------------------------------------------
inline void Tran1UnitSequence::appendNextSourceWord(LgsString aWord)
{
	sourceWords_.push_back(aWord);
}

// --------------------------------------------------------------------------
inline LgsStringVector* Tran1UnitSequence::sourceWords()
{
	return &sourceWords_;
}

// --------------------------------------------------------------------------
inline int Tran1UnitSequence::numberOfSwitch68()
{
	return numberSW68_;
}

// --------------------------------------------------------------------------
inline void Tran1Unit::resetArrayIndex()
{
	arrayIndex_ = 0;
}

// --------------------------------------------------------------------------
inline bool Tran1Unit::isValidArrayIndex()
{
	return arrayIndex_ < tran1TargetArraysSize_;
}

// --------------------------------------------------------------------------
inline void Tran1Unit::nextArrayIndex()
{
	arrayIndex_++;
}

// --------------------------------------------------------------------------
inline int Tran1Unit::currentSconpo()
{
	return currentTargetArrayValueFor(SCONPO);
}

// --------------------------------------------------------------------------
inline int Tran1Unit::currentOpadro()
{
	return currentTargetArrayValueFor(OPADRO);
}

// --------------------------------------------------------------------------
inline int Tran1Unit::currentTargetArrayValueFor(int targetArray)
{
	int value = 0;

	if (isValidArrayIndex())
	{
		value = tran1TargetArrays_[arrayIndex_][targetArray];
	}

	return value;
}

#endif // _Tran1Unit_h_
